// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type TypeDigest string

const (
	TypeDigestDigest TypeDigest = "digest"
)

func (e TypeDigest) ToPointer() *TypeDigest {
	return &e
}
func (e *TypeDigest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "digest":
		*e = TypeDigest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeDigest: %v", v)
	}
}

type Result8 struct {
	Type    *TypeDigest          `json:"type,omitempty"`
	Preview *DigestRegularOutput `json:"preview,omitempty"`
}

func (o *Result8) GetType() *TypeDigest {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result8) GetPreview() *DigestRegularOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeDelay string

const (
	TypeDelayDelay TypeDelay = "delay"
)

func (e TypeDelay) ToPointer() *TypeDelay {
	return &e
}
func (e *TypeDelay) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "delay":
		*e = TypeDelay(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeDelay: %v", v)
	}
}

type Result7 struct {
	Type    *TypeDelay           `json:"type,omitempty"`
	Preview *DigestRegularOutput `json:"preview,omitempty"`
}

func (o *Result7) GetType() *TypeDelay {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result7) GetPreview() *DigestRegularOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeChat string

const (
	TypeChatChat TypeChat = "chat"
)

func (e TypeChat) ToPointer() *TypeChat {
	return &e
}
func (e *TypeChat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "chat":
		*e = TypeChat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeChat: %v", v)
	}
}

type Result6 struct {
	Type    *TypeChat         `json:"type,omitempty"`
	Preview *ChatRenderOutput `json:"preview,omitempty"`
}

func (o *Result6) GetType() *TypeChat {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result6) GetPreview() *ChatRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypePush string

const (
	TypePushPush TypePush = "push"
)

func (e TypePush) ToPointer() *TypePush {
	return &e
}
func (e *TypePush) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "push":
		*e = TypePush(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypePush: %v", v)
	}
}

type Result5 struct {
	Type    *TypePush         `json:"type,omitempty"`
	Preview *PushRenderOutput `json:"preview,omitempty"`
}

func (o *Result5) GetType() *TypePush {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result5) GetPreview() *PushRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeSms string

const (
	TypeSmsSms TypeSms = "sms"
)

func (e TypeSms) ToPointer() *TypeSms {
	return &e
}
func (e *TypeSms) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sms":
		*e = TypeSms(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeSms: %v", v)
	}
}

type Result4 struct {
	Type    *TypeSms         `json:"type,omitempty"`
	Preview *SmsRenderOutput `json:"preview,omitempty"`
}

func (o *Result4) GetType() *TypeSms {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result4) GetPreview() *SmsRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeInApp string

const (
	TypeInAppInApp TypeInApp = "in_app"
)

func (e TypeInApp) ToPointer() *TypeInApp {
	return &e
}
func (e *TypeInApp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "in_app":
		*e = TypeInApp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeInApp: %v", v)
	}
}

type Result3 struct {
	Type    *TypeInApp         `json:"type,omitempty"`
	Preview *InAppRenderOutput `json:"preview,omitempty"`
}

func (o *Result3) GetType() *TypeInApp {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result3) GetPreview() *InAppRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeEmail2 string

const (
	TypeEmail2Email TypeEmail2 = "email"
)

func (e TypeEmail2) ToPointer() *TypeEmail2 {
	return &e
}
func (e *TypeEmail2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "email":
		*e = TypeEmail2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeEmail2: %v", v)
	}
}

type Result2 struct {
	Type    *TypeEmail2        `json:"type,omitempty"`
	Preview *EmailRenderOutput `json:"preview,omitempty"`
}

func (o *Result2) GetType() *TypeEmail2 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result2) GetPreview() *EmailRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type TypeEmail1 string

const (
	TypeEmail1Email TypeEmail1 = "email"
)

func (e TypeEmail1) ToPointer() *TypeEmail1 {
	return &e
}
func (e *TypeEmail1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "email":
		*e = TypeEmail1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeEmail1: %v", v)
	}
}

type Result1 struct {
	Type    *TypeEmail1        `json:"type,omitempty"`
	Preview *EmailRenderOutput `json:"preview,omitempty"`
}

func (o *Result1) GetType() *TypeEmail1 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Result1) GetPreview() *EmailRenderOutput {
	if o == nil {
		return nil
	}
	return o.Preview
}

type ResultUnionType string

const (
	ResultUnionTypeMapOfAny ResultUnionType = "mapOfAny"
	ResultUnionTypeResult1  ResultUnionType = "result_1"
	ResultUnionTypeResult2  ResultUnionType = "result_2"
	ResultUnionTypeResult3  ResultUnionType = "result_3"
	ResultUnionTypeResult4  ResultUnionType = "result_4"
	ResultUnionTypeResult5  ResultUnionType = "result_5"
	ResultUnionTypeResult6  ResultUnionType = "result_6"
	ResultUnionTypeResult7  ResultUnionType = "result_7"
	ResultUnionTypeResult8  ResultUnionType = "result_8"
)

// ResultUnion - Preview result
type ResultUnion struct {
	MapOfAny map[string]any `queryParam:"inline"`
	Result1  *Result1       `queryParam:"inline"`
	Result2  *Result2       `queryParam:"inline"`
	Result3  *Result3       `queryParam:"inline"`
	Result4  *Result4       `queryParam:"inline"`
	Result5  *Result5       `queryParam:"inline"`
	Result6  *Result6       `queryParam:"inline"`
	Result7  *Result7       `queryParam:"inline"`
	Result8  *Result8       `queryParam:"inline"`

	Type ResultUnionType
}

func CreateResultUnionMapOfAny(mapOfAny map[string]any) ResultUnion {
	typ := ResultUnionTypeMapOfAny

	return ResultUnion{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateResultUnionResult1(result1 Result1) ResultUnion {
	typ := ResultUnionTypeResult1

	return ResultUnion{
		Result1: &result1,
		Type:    typ,
	}
}

func CreateResultUnionResult2(result2 Result2) ResultUnion {
	typ := ResultUnionTypeResult2

	return ResultUnion{
		Result2: &result2,
		Type:    typ,
	}
}

func CreateResultUnionResult3(result3 Result3) ResultUnion {
	typ := ResultUnionTypeResult3

	return ResultUnion{
		Result3: &result3,
		Type:    typ,
	}
}

func CreateResultUnionResult4(result4 Result4) ResultUnion {
	typ := ResultUnionTypeResult4

	return ResultUnion{
		Result4: &result4,
		Type:    typ,
	}
}

func CreateResultUnionResult5(result5 Result5) ResultUnion {
	typ := ResultUnionTypeResult5

	return ResultUnion{
		Result5: &result5,
		Type:    typ,
	}
}

func CreateResultUnionResult6(result6 Result6) ResultUnion {
	typ := ResultUnionTypeResult6

	return ResultUnion{
		Result6: &result6,
		Type:    typ,
	}
}

func CreateResultUnionResult7(result7 Result7) ResultUnion {
	typ := ResultUnionTypeResult7

	return ResultUnion{
		Result7: &result7,
		Type:    typ,
	}
}

func CreateResultUnionResult8(result8 Result8) ResultUnion {
	typ := ResultUnionTypeResult8

	return ResultUnion{
		Result8: &result8,
		Type:    typ,
	}
}

func (u *ResultUnion) UnmarshalJSON(data []byte) error {

	var result1 Result1 = Result1{}
	if err := utils.UnmarshalJSON(data, &result1, "", true, true); err == nil {
		u.Result1 = &result1
		u.Type = ResultUnionTypeResult1
		return nil
	}

	var result2 Result2 = Result2{}
	if err := utils.UnmarshalJSON(data, &result2, "", true, true); err == nil {
		u.Result2 = &result2
		u.Type = ResultUnionTypeResult2
		return nil
	}

	var result3 Result3 = Result3{}
	if err := utils.UnmarshalJSON(data, &result3, "", true, true); err == nil {
		u.Result3 = &result3
		u.Type = ResultUnionTypeResult3
		return nil
	}

	var result4 Result4 = Result4{}
	if err := utils.UnmarshalJSON(data, &result4, "", true, true); err == nil {
		u.Result4 = &result4
		u.Type = ResultUnionTypeResult4
		return nil
	}

	var result5 Result5 = Result5{}
	if err := utils.UnmarshalJSON(data, &result5, "", true, true); err == nil {
		u.Result5 = &result5
		u.Type = ResultUnionTypeResult5
		return nil
	}

	var result6 Result6 = Result6{}
	if err := utils.UnmarshalJSON(data, &result6, "", true, true); err == nil {
		u.Result6 = &result6
		u.Type = ResultUnionTypeResult6
		return nil
	}

	var result7 Result7 = Result7{}
	if err := utils.UnmarshalJSON(data, &result7, "", true, true); err == nil {
		u.Result7 = &result7
		u.Type = ResultUnionTypeResult7
		return nil
	}

	var result8 Result8 = Result8{}
	if err := utils.UnmarshalJSON(data, &result8, "", true, true); err == nil {
		u.Result8 = &result8
		u.Type = ResultUnionTypeResult8
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, true); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = ResultUnionTypeMapOfAny
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResultUnion", string(data))
}

func (u ResultUnion) MarshalJSON() ([]byte, error) {
	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.Result1 != nil {
		return utils.MarshalJSON(u.Result1, "", true)
	}

	if u.Result2 != nil {
		return utils.MarshalJSON(u.Result2, "", true)
	}

	if u.Result3 != nil {
		return utils.MarshalJSON(u.Result3, "", true)
	}

	if u.Result4 != nil {
		return utils.MarshalJSON(u.Result4, "", true)
	}

	if u.Result5 != nil {
		return utils.MarshalJSON(u.Result5, "", true)
	}

	if u.Result6 != nil {
		return utils.MarshalJSON(u.Result6, "", true)
	}

	if u.Result7 != nil {
		return utils.MarshalJSON(u.Result7, "", true)
	}

	if u.Result8 != nil {
		return utils.MarshalJSON(u.Result8, "", true)
	}

	return nil, errors.New("could not marshal union type ResultUnion: all fields are null")
}

type GeneratePreviewResponseDto struct {
	// Preview payload example
	PreviewPayloadExample PreviewPayloadDto `json:"previewPayloadExample"`
	// The payload schema that was used to generate the preview payload example
	Schema map[string]any `json:"schema,omitempty"`
	// Preview result
	Result ResultUnion `json:"result"`
}

func (o *GeneratePreviewResponseDto) GetPreviewPayloadExample() PreviewPayloadDto {
	if o == nil {
		return PreviewPayloadDto{}
	}
	return o.PreviewPayloadExample
}

func (o *GeneratePreviewResponseDto) GetSchema() map[string]any {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *GeneratePreviewResponseDto) GetResult() ResultUnion {
	if o == nil {
		return ResultUnion{}
	}
	return o.Result
}
