// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

// TriggerEventRequestDtoOverrides - This could be used to override provider specific configurations
type TriggerEventRequestDtoOverrides struct {
	// This could be used to override provider specific configurations
	Steps map[string]StepsOverrides `json:"steps,omitempty"`
	// Overrides the provider configuration for the entire workflow and all steps
	Providers map[string]map[string]any `json:"providers,omitempty"`
	// Override the email provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Email map[string]any `json:"email,omitempty"`
	// Override the push provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Push map[string]any `json:"push,omitempty"`
	// Override the sms provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Sms map[string]any `json:"sms,omitempty"`
	// Override the chat provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Chat map[string]any `json:"chat,omitempty"`
	// Override the layout identifier for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	LayoutIdentifier *string `json:"layoutIdentifier,omitempty"`
}

func (o *TriggerEventRequestDtoOverrides) GetSteps() map[string]StepsOverrides {
	if o == nil {
		return nil
	}
	return o.Steps
}

func (o *TriggerEventRequestDtoOverrides) GetProviders() map[string]map[string]any {
	if o == nil {
		return nil
	}
	return o.Providers
}

func (o *TriggerEventRequestDtoOverrides) GetEmail() map[string]any {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *TriggerEventRequestDtoOverrides) GetPush() map[string]any {
	if o == nil {
		return nil
	}
	return o.Push
}

func (o *TriggerEventRequestDtoOverrides) GetSms() map[string]any {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (o *TriggerEventRequestDtoOverrides) GetChat() map[string]any {
	if o == nil {
		return nil
	}
	return o.Chat
}

func (o *TriggerEventRequestDtoOverrides) GetLayoutIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.LayoutIdentifier
}

type ToUnion1Type string

const (
	ToUnion1TypeSubscriberPayloadDto ToUnion1Type = "SubscriberPayloadDto"
	ToUnion1TypeTopicPayloadDto      ToUnion1Type = "TopicPayloadDto"
	ToUnion1TypeStr                  ToUnion1Type = "str"
)

type ToUnion1 struct {
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline"`
	TopicPayloadDto      *TopicPayloadDto      `queryParam:"inline"`
	Str                  *string               `queryParam:"inline"`

	Type ToUnion1Type
}

func CreateToUnion1SubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) ToUnion1 {
	typ := ToUnion1TypeSubscriberPayloadDto

	return ToUnion1{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func CreateToUnion1TopicPayloadDto(topicPayloadDto TopicPayloadDto) ToUnion1 {
	typ := ToUnion1TypeTopicPayloadDto

	return ToUnion1{
		TopicPayloadDto: &topicPayloadDto,
		Type:            typ,
	}
}

func CreateToUnion1Str(str string) ToUnion1 {
	typ := ToUnion1TypeStr

	return ToUnion1{
		Str:  &str,
		Type: typ,
	}
}

func (u *ToUnion1) UnmarshalJSON(data []byte) error {

	var topicPayloadDto TopicPayloadDto = TopicPayloadDto{}
	if err := utils.UnmarshalJSON(data, &topicPayloadDto, "", true, true); err == nil {
		u.TopicPayloadDto = &topicPayloadDto
		u.Type = ToUnion1TypeTopicPayloadDto
		return nil
	}

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, true); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = ToUnion1TypeSubscriberPayloadDto
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ToUnion1TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ToUnion1", string(data))
}

func (u ToUnion1) MarshalJSON() ([]byte, error) {
	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	if u.TopicPayloadDto != nil {
		return utils.MarshalJSON(u.TopicPayloadDto, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ToUnion1: all fields are null")
}

type ToUnion2Type string

const (
	ToUnion2TypeArrayOfToUnion1      ToUnion2Type = "arrayOfToUnion1"
	ToUnion2TypeStr                  ToUnion2Type = "str"
	ToUnion2TypeSubscriberPayloadDto ToUnion2Type = "SubscriberPayloadDto"
	ToUnion2TypeTopicPayloadDto      ToUnion2Type = "TopicPayloadDto"
)

// ToUnion2 - The recipients list of people who will receive the notification.
type ToUnion2 struct {
	ArrayOfToUnion1      []ToUnion1            `queryParam:"inline"`
	Str                  *string               `queryParam:"inline"`
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline"`
	TopicPayloadDto      *TopicPayloadDto      `queryParam:"inline"`

	Type ToUnion2Type
}

func CreateToUnion2ArrayOfToUnion1(arrayOfToUnion1 []ToUnion1) ToUnion2 {
	typ := ToUnion2TypeArrayOfToUnion1

	return ToUnion2{
		ArrayOfToUnion1: arrayOfToUnion1,
		Type:            typ,
	}
}

func CreateToUnion2Str(str string) ToUnion2 {
	typ := ToUnion2TypeStr

	return ToUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateToUnion2SubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) ToUnion2 {
	typ := ToUnion2TypeSubscriberPayloadDto

	return ToUnion2{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func CreateToUnion2TopicPayloadDto(topicPayloadDto TopicPayloadDto) ToUnion2 {
	typ := ToUnion2TypeTopicPayloadDto

	return ToUnion2{
		TopicPayloadDto: &topicPayloadDto,
		Type:            typ,
	}
}

func (u *ToUnion2) UnmarshalJSON(data []byte) error {

	var topicPayloadDto TopicPayloadDto = TopicPayloadDto{}
	if err := utils.UnmarshalJSON(data, &topicPayloadDto, "", true, true); err == nil {
		u.TopicPayloadDto = &topicPayloadDto
		u.Type = ToUnion2TypeTopicPayloadDto
		return nil
	}

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, true); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = ToUnion2TypeSubscriberPayloadDto
		return nil
	}

	var arrayOfToUnion1 []ToUnion1 = []ToUnion1{}
	if err := utils.UnmarshalJSON(data, &arrayOfToUnion1, "", true, true); err == nil {
		u.ArrayOfToUnion1 = arrayOfToUnion1
		u.Type = ToUnion2TypeArrayOfToUnion1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ToUnion2TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ToUnion2", string(data))
}

func (u ToUnion2) MarshalJSON() ([]byte, error) {
	if u.ArrayOfToUnion1 != nil {
		return utils.MarshalJSON(u.ArrayOfToUnion1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	if u.TopicPayloadDto != nil {
		return utils.MarshalJSON(u.TopicPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type ToUnion2: all fields are null")
}

type TriggerEventRequestDtoActorType string

const (
	TriggerEventRequestDtoActorTypeStr                  TriggerEventRequestDtoActorType = "str"
	TriggerEventRequestDtoActorTypeSubscriberPayloadDto TriggerEventRequestDtoActorType = "SubscriberPayloadDto"
)

// TriggerEventRequestDtoActor - It is used to display the Avatar of the provided actor's subscriber id or actor object.
//
//	If a new actor object is provided, we will create a new subscriber in our system
type TriggerEventRequestDtoActor struct {
	Str                  *string               `queryParam:"inline"`
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline"`

	Type TriggerEventRequestDtoActorType
}

func CreateTriggerEventRequestDtoActorStr(str string) TriggerEventRequestDtoActor {
	typ := TriggerEventRequestDtoActorTypeStr

	return TriggerEventRequestDtoActor{
		Str:  &str,
		Type: typ,
	}
}

func CreateTriggerEventRequestDtoActorSubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) TriggerEventRequestDtoActor {
	typ := TriggerEventRequestDtoActorTypeSubscriberPayloadDto

	return TriggerEventRequestDtoActor{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func (u *TriggerEventRequestDtoActor) UnmarshalJSON(data []byte) error {

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, true); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = TriggerEventRequestDtoActorTypeSubscriberPayloadDto
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TriggerEventRequestDtoActorTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TriggerEventRequestDtoActor", string(data))
}

func (u TriggerEventRequestDtoActor) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type TriggerEventRequestDtoActor: all fields are null")
}

type TriggerEventRequestDtoTenantType string

const (
	TriggerEventRequestDtoTenantTypeStr              TriggerEventRequestDtoTenantType = "str"
	TriggerEventRequestDtoTenantTypeTenantPayloadDto TriggerEventRequestDtoTenantType = "TenantPayloadDto"
)

// TriggerEventRequestDtoTenant - It is used to specify a tenant context during trigger event.
//
//	Existing tenants will be updated with the provided details.
type TriggerEventRequestDtoTenant struct {
	Str              *string           `queryParam:"inline"`
	TenantPayloadDto *TenantPayloadDto `queryParam:"inline"`

	Type TriggerEventRequestDtoTenantType
}

func CreateTriggerEventRequestDtoTenantStr(str string) TriggerEventRequestDtoTenant {
	typ := TriggerEventRequestDtoTenantTypeStr

	return TriggerEventRequestDtoTenant{
		Str:  &str,
		Type: typ,
	}
}

func CreateTriggerEventRequestDtoTenantTenantPayloadDto(tenantPayloadDto TenantPayloadDto) TriggerEventRequestDtoTenant {
	typ := TriggerEventRequestDtoTenantTypeTenantPayloadDto

	return TriggerEventRequestDtoTenant{
		TenantPayloadDto: &tenantPayloadDto,
		Type:             typ,
	}
}

func (u *TriggerEventRequestDtoTenant) UnmarshalJSON(data []byte) error {

	var tenantPayloadDto TenantPayloadDto = TenantPayloadDto{}
	if err := utils.UnmarshalJSON(data, &tenantPayloadDto, "", true, true); err == nil {
		u.TenantPayloadDto = &tenantPayloadDto
		u.Type = TriggerEventRequestDtoTenantTypeTenantPayloadDto
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TriggerEventRequestDtoTenantTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TriggerEventRequestDtoTenant", string(data))
}

func (u TriggerEventRequestDtoTenant) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.TenantPayloadDto != nil {
		return utils.MarshalJSON(u.TenantPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type TriggerEventRequestDtoTenant: all fields are null")
}

type TriggerEventRequestDto struct {
	// The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.
	WorkflowID string `json:"name"`
	// The payload object is used to pass additional custom information that could be
	//     used to render the workflow, or perform routing rules based on it.
	//       This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.
	Payload map[string]any `json:"payload,omitempty"`
	// This could be used to override provider specific configurations
	Overrides *TriggerEventRequestDtoOverrides `json:"overrides,omitempty"`
	// The recipients list of people who will receive the notification.
	To ToUnion2 `json:"to"`
	// A unique identifier for this transaction, we will generate a UUID if not provided.
	TransactionID *string `json:"transactionId,omitempty"`
	// It is used to display the Avatar of the provided actor's subscriber id or actor object.
	//     If a new actor object is provided, we will create a new subscriber in our system
	Actor *TriggerEventRequestDtoActor `json:"actor,omitempty"`
	// It is used to specify a tenant context during trigger event.
	//     Existing tenants will be updated with the provided details.
	Tenant *TriggerEventRequestDtoTenant `json:"tenant,omitempty"`
}

func (o *TriggerEventRequestDto) GetWorkflowID() string {
	if o == nil {
		return ""
	}
	return o.WorkflowID
}

func (o *TriggerEventRequestDto) GetPayload() map[string]any {
	if o == nil {
		return nil
	}
	return o.Payload
}

func (o *TriggerEventRequestDto) GetOverrides() *TriggerEventRequestDtoOverrides {
	if o == nil {
		return nil
	}
	return o.Overrides
}

func (o *TriggerEventRequestDto) GetTo() ToUnion2 {
	if o == nil {
		return ToUnion2{}
	}
	return o.To
}

func (o *TriggerEventRequestDto) GetTransactionID() *string {
	if o == nil {
		return nil
	}
	return o.TransactionID
}

func (o *TriggerEventRequestDto) GetActor() *TriggerEventRequestDtoActor {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *TriggerEventRequestDto) GetTenant() *TriggerEventRequestDtoTenant {
	if o == nil {
		return nil
	}
	return o.Tenant
}
